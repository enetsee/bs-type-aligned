// Generated by BUCKLESCRIPT, PLEASE EDIT WITH CARE
'use strict';

var Curry = require("bs-platform/lib/js/curry.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Seq$TypeAligned = require("./Seq.bs.js");
var List$TypeAligned = require("./List.bs.js");
var SnocList$TypeAligned = require("./SnocList.bs.js");

function Make(funarg) {
  var ConsList = List$TypeAligned.Make(funarg);
  var SnocList = SnocList$TypeAligned.Make(funarg);
  var rotate = function (f, a, r) {
    if (f) {
      if (a) {
        var match = a[0];
        var match$1 = f[0];
        return Curry._2(ConsList.cons, match$1[0], rotate(match$1[1], match[0], Curry._2(ConsList.cons, match[1], r)));
      } else {
        return Pervasives.failwith("can't happen");
      }
    } else if (a) {
      var match$2 = a[0];
      if (match$2[0]) {
        return Pervasives.failwith("can't happen");
      } else {
        return Curry._2(ConsList.cons, match$2[1], r);
      }
    } else {
      return Pervasives.failwith("can't happen");
    }
  };
  var revAppend = function (l, r) {
    return rotate(l, r, ConsList.empty);
  };
  var empty = /* RQ */[/* tuple */[
      ConsList.empty,
      SnocList.empty,
      ConsList.empty
    ]];
  var queue = function (f, r, a) {
    if (a) {
      return /* RQ */[/* tuple */[
                f,
                r,
                a[0][1]
              ]];
    } else {
      var f$prime = rotate(f, r, ConsList.empty);
      return /* RQ */[/* tuple */[
                f$prime,
                SnocList.empty,
                f$prime
              ]];
    }
  };
  var singleton = function (x) {
    var c = Curry._1(ConsList.singleton, x);
    return queue(c, SnocList.empty, c);
  };
  var snoc = function (param, x) {
    var match = param[0];
    return queue(match[0], /* Snoc */[/* tuple */[
                  match[1],
                  x
                ]], match[2]);
  };
  var consOrSnoc = /* `Snoc */[
    925929103,
    snoc
  ];
  var viewLeft = function (param) {
    var match = param[0];
    var match$1 = match[0];
    if (match$1) {
      var match$2 = match$1[0];
      return /* ConsL */[/* tuple */[
                match$2[0],
                queue(match$2[1], match[1], match[2])
              ]];
    } else if (match[1] || match[2]) {
      return Pervasives.failwith("cannot view left");
    } else {
      return /* EmptyL */0;
    }
  };
  var view = /* `Left */[
    847852583,
    viewLeft
  ];
  var include = Seq$TypeAligned.Make({
        F: funarg,
        empty: empty,
        singleton: singleton,
        consOrSnoc: consOrSnoc,
        view: view
      });
  return {
          F: funarg,
          ConsList: ConsList,
          SnocList: SnocList,
          rotate: rotate,
          revAppend: revAppend,
          queue: queue,
          empty: include.empty,
          singleton: include.singleton,
          cons: include.cons,
          snoc: include.snoc,
          viewLeft: include.viewLeft,
          viewRight: include.viewRight
        };
}

exports.Make = Make;
/* No side effect */
